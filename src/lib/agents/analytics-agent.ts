/**
 * Analytics Agent
 * Specialized agent for data analysis, sales metrics, and business insights
 */

import { BaseAgent } from './base-agent';
import { ANALYTICS_CONFIG, ROUTING_KEYWORDS } from './config';
import type { AgentContext, AgentResponse } from './types';

export class AnalyticsAgent extends BaseAgent {
  constructor() {
    super(
      'analytics',
      'Analytics Agent',
      'Expert in data analysis, sales metrics, and business insights',
      [
        {
          name: 'Sales Analysis',
          description: 'Analyze sales data, revenue trends, and conversion metrics',
          examples: ['Total sales today', 'Best selling products', 'Revenue comparison'],
          priority: 10
        },
        {
          name: 'Product Performance',
          description: 'Track product metrics, inventory, and popularity trends',
          examples: ['Top products', 'Low stock alerts', 'Category performance'],
          priority: 9
        },
        {
          name: 'Customer Analytics',
          description: 'Customer behavior analysis and segmentation',
          examples: ['Customer lifetime value', 'Purchase patterns', 'Customer segments'],
          priority: 8
        },
        {
          name: 'Financial Reporting',
          description: 'Financial KPIs, profit analysis, and business metrics',
          examples: ['Monthly revenue', 'Profit margins', 'Cost analysis'],
          priority: 9
        },
        {
          name: 'Trend Analysis',
          description: 'Identify trends, patterns, and forecasting',
          examples: ['Seasonal trends', 'Growth predictions', 'Market patterns'],
          priority: 7
        }
      ],
      ANALYTICS_CONFIG
    );
  }

  async process(context: AgentContext): Promise<AgentResponse> {
    const startTime = Date.now();
    this.log('info', `Processing analytics query: "${context.userMessage}"`);

    try {
      // Get relevant context from RAG
      const ragContext = await this.getRelevantContext(context.userMessage, context);
      
      // Identify the type of analytics request
      const queryType = this.identifyQueryType(context.userMessage);
      this.log('debug', `Identified query type: ${queryType}`);

      // Generate appropriate response based on query type
      let response: string;
      let confidence: number;

      switch (queryType.type) {
        case 'product_pricing':
          response = await this.generateProductPricing(context, ragContext);
          confidence = 0.95;
          break;
        case 'sales_summary':
          response = await this.generateSalesSummary(context, ragContext);
          confidence = 0.9;
          break;
        case 'product_analysis':
          response = await this.generateProductAnalysis(context, ragContext);
          confidence = 0.85;
          break;
        case 'customer_insights':
          response = await this.generateCustomerInsights(context, ragContext);
          confidence = 0.8;
          break;
        case 'financial_report':
          response = await this.generateFinancialReport(context, ragContext);
          confidence = 0.85;
          break;
        case 'trend_analysis':
          response = await this.generateTrendAnalysis(context, ragContext);
          confidence = 0.75;
          break;
        case 'comparison':
          response = await this.generateComparison(context, ragContext);
          confidence = 0.8;
          break;
        default:
          response = await this.generateGeneralAnalytics(context, ragContext);
          confidence = 0.6;
      }

      const executionTime = Date.now() - startTime;
      this.log('info', `Analytics response generated in ${executionTime}ms`);

      return this.createResponse(
        true,
        response,
        confidence,
        `Analytics query processed: ${queryType.reasoning}`,
        ragContext,
        executionTime
      );

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.log('error', `Analytics processing failed: ${errorMessage}`);
      
      // üî• ENHANCED: Provide useful analytics advice even on error
      const fallbackResponse = `üìä **Analytics de Tu Tienda - Sistema en Sincronizaci√≥n**

He detectado un problema t√©cnico temporal, pero puedo ayudarte con an√°lisis generales:

**üéØ M√©tricas Clave a Monitorear:**
‚Ä¢ **Conversi√≥n**: % de visitantes que compran
‚Ä¢ **Ticket promedio**: Valor promedio por venta
‚Ä¢ **Retorno de clientes**: % de clientes que recompran
‚Ä¢ **Margen bruto**: Ganancia despu√©s de costos directos

**üìà Estrategias de Crecimiento:**
‚Ä¢ **A/B Testing**: Prueba diferentes versiones de productos
‚Ä¢ **Upselling**: Sugiere productos complementarios
‚Ä¢ **Email marketing**: Reactivar clientes inactivos
‚Ä¢ **SEO**: Mejorar posicionamiento en b√∫squedas

**üîß Herramientas Recomendadas:**
‚Ä¢ Google Analytics para tr√°fico web
‚Ä¢ Pixel de Facebook para remarketing
‚Ä¢ Reviews autom√°ticos para confianza

Estoy solucionando el problema t√©cnico. ¬øHay alg√∫n aspecto espec√≠fico de analytics que te interese mientras tanto?`;

      return {
        success: true,
        agentType: this.type,
        response: fallbackResponse,
        confidence: 0.7,
        reasoning: 'Fallback analytics advice provided due to technical issue',
                 metadata: {
           fallbackUsed: true,
           ragUsed: false
         }
       };
    }
  }
  }

  protected async calculateHandlingScore(context: AgentContext): Promise<{ confidence: number; reasoning: string }> {
    const { userMessage } = context;
    const lowerMessage = userMessage.toLowerCase();

    // Check for analytics keywords
    const keywordCheck = this.hasKeywords(lowerMessage, ROUTING_KEYWORDS.analytics);
    let score = keywordCheck.score;

    // Boost for specific patterns
    if (lowerMessage.includes('cu√°nto') && (lowerMessage.includes('vend') || lowerMessage.includes('gan√©'))) {
      score += 0.3;
    }
    if (lowerMessage.includes('reporte') || lowerMessage.includes('an√°lisis') || lowerMessage.includes('datos')) {
      score += 0.2;
    }
    if (lowerMessage.includes('producto') && lowerMessage.includes('m√°s')) {
      score += 0.2;
    }

    const confidence = Math.min(score, 1.0);
    const reasoning = keywordCheck.found ? 
      `Found analytics keywords: ${keywordCheck.matches.join(', ')}` :
      'No specific analytics keywords found';

    return { confidence, reasoning };
  }

  private identifyQueryType(message: string): { type: string; reasoning: string; confidence: number } {
    const lowerMessage = message.toLowerCase();

    // üî• NEW: Product pricing analysis queries
    if (lowerMessage.includes('caro') || lowerMessage.includes('barato') || 
        (lowerMessage.includes('producto') && lowerMessage.includes('precio'))) {
      return { type: 'product_pricing', reasoning: 'Product pricing analysis query detected', confidence: 0.95 };
    }

    // Sales summary queries
    if (lowerMessage.includes('cu√°nto') && (lowerMessage.includes('vend') || lowerMessage.includes('gan√©'))) {
      return { type: 'sales_summary', reasoning: 'Sales amount query detected', confidence: 0.9 };
    }
    if (lowerMessage.includes('ventas') && (lowerMessage.includes('hoy') || lowerMessage.includes('ayer') || lowerMessage.includes('mes'))) {
      return { type: 'sales_summary', reasoning: 'Time-based sales query', confidence: 0.85 };
    }

    // Product analysis
    if (lowerMessage.includes('producto') && (lowerMessage.includes('m√°s') || lowerMessage.includes('mejor') || lowerMessage.includes('top'))) {
      return { type: 'product_analysis', reasoning: 'Product ranking query', confidence: 0.9 };
    }
    if (lowerMessage.includes('inventario') || lowerMessage.includes('stock')) {
      return { type: 'product_analysis', reasoning: 'Inventory query', confidence: 0.8 };
    }

    // Customer insights
    if (lowerMessage.includes('cliente') && (lowerMessage.includes('compra') || lowerMessage.includes('comportamiento'))) {
      return { type: 'customer_insights', reasoning: 'Customer behavior query', confidence: 0.8 };
    }

    // Financial reports
    if (lowerMessage.includes('ingreso') || lowerMessage.includes('ganancia') || lowerMessage.includes('facturaci√≥n')) {
      return { type: 'financial_report', reasoning: 'Financial metrics query', confidence: 0.85 };
    }

    // Trend analysis
    if (lowerMessage.includes('tendencia') || lowerMessage.includes('crecimiento') || lowerMessage.includes('evoluci√≥n')) {
      return { type: 'trend_analysis', reasoning: 'Trend analysis query', confidence: 0.8 };
    }

    // Comparison queries
    if (lowerMessage.includes('comparar') || lowerMessage.includes('vs') || lowerMessage.includes('contra')) {
      return { type: 'comparison', reasoning: 'Comparison analysis query', confidence: 0.75 };
    }

    return { type: 'general', reasoning: 'General analytics query', confidence: 0.5 };
  }

  private async generateSalesSummary(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext || 'No hay datos espec√≠ficos disponibles'
    });

    const enhancedPrompt = `${userPrompt}

Proporciona un resumen de ventas detallado que incluya:
- Cifras espec√≠ficas de ventas (si est√°n disponibles)
- Comparaciones con per√≠odos anteriores
- Insights sobre el rendimiento
- Recomendaciones basadas en los datos

Formato de respuesta profesional en espa√±ol.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateProductAnalysis(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    
    // Check if we have actual product data
    const hasData = ragContext && ragContext.length > 50 && !ragContext.includes('No hay datos');
    
    if (!hasData) {
      return `üìä **An√°lisis de Productos - Configuraci√≥n Inicial Requerida**

**üîç Estado Actual:**
No encuentro productos en tu cat√°logo para analizar. Esto es normal si:
- Es una tienda nueva
- Los productos est√°n en borrador (no publicados)
- Hay productos demo que no son reales

**üìà Una vez que agregues productos reales, podr√© hacer:**

**An√°lisis de Performance:**
- üèÜ Ranking de productos m√°s vendidos
- üìâ Identificaci√≥n de productos con bajo rendimiento  
- üí∞ An√°lisis de rentabilidad por producto
- üìä Performance por categor√≠as

**M√©tricas Detalladas:**
- Tasa de conversi√≥n por producto
- Ticket promedio por categor√≠a
- Velocidad de rotaci√≥n de inventario
- An√°lisis estacional de demanda

**Recomendaciones Estrat√©gicas:**
- Optimizaci√≥n de precios
- Estrategias de cross-selling y up-selling
- Identificaci√≥n de productos estrella
- Detecci√≥n de oportunidades de mejora

**üöÄ Para comenzar:**
1. **Agrega productos reales** en tu panel de Tienda Nube
2. **Publ√≠calos** (importante: no dejarlos en borrador)
3. **Incluye informaci√≥n completa:** precios, descripciones, stock
4. **Regresa aqu√≠** y pregunta: "¬øcu√°les son mis productos m√°s vendidos?"

**üí° Tip Profesional:** Empieza con 3-5 productos bien configurados. Es mejor tener pocos productos completos que muchos incompletos.

¬øTe ayudo con estrategias espec√≠ficas para tu tipo de negocio mientras preparas tu cat√°logo?`;
    }

    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext
    });

    const enhancedPrompt = `${userPrompt}

Realiza un an√°lisis de productos que incluya:
- Productos m√°s vendidos y su performance
- An√°lisis de categor√≠as
- Recomendaciones de inventario
- Oportunidades de mejora
- Insights sobre demanda y tendencias

Usa datos espec√≠ficos cuando est√©n disponibles y proporciona recomendaciones accionables.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateProductPricing(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    
    // Check if we have actual product data
    const hasData = ragContext && ragContext.length > 50 && !ragContext.includes('No hay datos');
    
    if (!hasData) {
      // üî• AUTO-SYNC: Trigger immediate RAG sync when no product data found
      console.warn(`[ANALYTICS-AGENT] No product data found for pricing query. Triggering sync for store: ${context.storeId}`);
      
      try {
        // Fire sync request (don't wait for response to avoid timeout)
        const syncUrl = process.env.VERCEL_URL ? 
          `https://${process.env.VERCEL_URL}/api/stores/${context.storeId}/sync-rag` :
          `https://fini-tn.vercel.app/api/stores/${context.storeId}/sync-rag`;
          
        fetch(syncUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        }).catch(error => {
          console.warn(`[ANALYTICS-AGENT] Auto-sync failed for store ${context.storeId}:`, error);
        });
      } catch (error) {
        console.warn(`[ANALYTICS-AGENT] Auto-sync trigger failed:`, error);
      }

      // üöÄ ENHANCED: Provide useful pricing strategy advice even without specific data
      return `üéØ **Estrategia de Precios para tu Tienda**

He activado la sincronizaci√≥n de datos de tu tienda para obtener informaci√≥n espec√≠fica de tus productos. Mientras tanto, aqu√≠ tienes estrategias de pricing para e-commerce:

**üîç An√°lisis de Precios Recomendado:**
‚Ä¢ **Competencia directa**: Investiga precios de productos similares
‚Ä¢ **Margen objetivo**: Apunta a 40-60% de margen bruto en promedio
‚Ä¢ **Precio psicol√≥gico**: Usa terminaciones en .99 o .95

**üìä Estrategias de Pricing:**
‚Ä¢ **Penetraci√≥n**: Precios bajos para ganar mercado inicialmente
‚Ä¢ **Premium**: Precios altos para posicionamiento de calidad
‚Ä¢ **Din√°mico**: Ajustar seg√∫n demanda y temporada

**üöÄ Pr√≥ximos Pasos:**
1. Completa la sincronizaci√≥n de productos (en progreso)
2. Analiza precios de competidores directos
3. Define tu propuesta de valor √∫nica

¬øTe gustar√≠a que analice alg√∫n aspecto espec√≠fico de pricing una vez que termine la sincronizaci√≥n de datos?`;
    }
      
      return `üí∞ **An√°lisis de Precios - Sincronizando Datos**

**üîÑ Estado Actual:**
He detectado que necesitas an√°lisis de precios y estoy sincronizando autom√°ticamente los datos de tu cat√°logo.

**‚ö° Mientras tanto:**
Verifica que en tu panel de Tienda Nube tengas:
- ‚úÖ Productos **publicados** (no en borrador)
- ‚úÖ Precios definidos para cada producto
- ‚úÖ Variantes con precios espec√≠ficos si aplica

**üöÄ En 2-3 minutos, podr√°s preguntar:**
- üíé "¬øCu√°l es mi producto m√°s caro?"
- üí∞ "¬øCu√°l es mi producto m√°s barato?"
- üìä "Ranking de productos por precio"
- üìà "An√°lisis de precios por categor√≠a"

**üí° Tip:** Despu√©s de la sincronizaci√≥n, vuelve a preguntar espec√≠ficamente sobre tu producto m√°s caro y te dar√© datos exactos.

La sincronizaci√≥n est√° en progreso en segundo plano. ¬°Intenta nuevamente en unos minutos!`;
    }

    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext
    });

    const enhancedPrompt = `${userPrompt}

ENFOQUE ESPEC√çFICO: AN√ÅLISIS DE PRECIOS DE PRODUCTOS

La consulta del usuario es sobre precios de productos. Analiza los datos disponibles y proporciona:

1. **Identificaci√≥n directa del producto solicitado** (m√°s caro, m√°s barato, etc.)
2. **Precio espec√≠fico y nombre del producto**
3. **Contexto adicional relevante** (categor√≠a, comparaci√≥n con otros productos)
4. **Insight de pricing** si es relevante

Si hay m√∫ltiples productos, muestra el ranking top 3-5.
Usa n√∫meros espec√≠ficos y nombres de productos reales.
S√© directo y conciso.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateCustomerInsights(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext || 'No hay datos de clientes disponibles'
    });

    const enhancedPrompt = `${userPrompt}

Proporciona insights de clientes que incluyan:
- Patrones de comportamiento de compra
- Segmentaci√≥n de clientes
- Valor de vida del cliente (CLV)
- An√°lisis de retenci√≥n y frecuencia
- Recomendaciones para mejorar la experiencia del cliente

Enf√≥cate en insights accionables para el negocio.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateFinancialReport(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext || 'No hay datos financieros disponibles'
    });

    const enhancedPrompt = `${userPrompt}

Genera un reporte financiero que incluya:
- M√©tricas clave de revenue y profit
- An√°lisis de m√°rgenes y costos
- KPIs financieros importantes
- Comparaciones temporales
- Recomendaciones para optimizaci√≥n financiera

Presenta datos claros con contexto y recomendaciones.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateTrendAnalysis(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext || 'No hay datos de tendencias disponibles'
    });

    const enhancedPrompt = `${userPrompt}

Realiza un an√°lisis de tendencias que incluya:
- Identificaci√≥n de patrones y tendencias
- An√°lisis estacional si aplica
- Predicciones y forecasting b√°sico
- Factores que influyen en las tendencias
- Recomendaciones estrat√©gicas basadas en las tendencias

Proporciona insights prospectivos para la toma de decisiones.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateComparison(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext || 'No hay datos para comparaci√≥n disponibles'
    });

    const enhancedPrompt = `${userPrompt}

Realiza una comparaci√≥n detallada que incluya:
- Comparaci√≥n de m√©tricas espec√≠ficas
- An√°lisis de diferencias y cambios
- Contexto sobre las variaciones
- Factores que explican los cambios
- Recomendaciones basadas en la comparaci√≥n

Presenta datos comparativos de manera clara y con insights valiosos.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }

  private async generateGeneralAnalytics(context: AgentContext, ragContext: string): Promise<string> {
    const systemPrompt = this.config.prompts.systemPrompt;
    const userPrompt = this.formatPrompt(this.config.prompts.userPrompt, {
      userMessage: context.userMessage,
      context: ragContext || 'Datos limitados disponibles'
    });

    const enhancedPrompt = `${userPrompt}

Proporciona un an√°lisis general que incluya:
- Resumen de datos disponibles
- Insights principales del negocio
- M√©tricas clave relevantes
- Recomendaciones generales
- Pr√≥ximos pasos sugeridos

Si no hay datos espec√≠ficos, proporciona un framework de an√°lisis √∫til.`;

    return await this.generateResponse(systemPrompt, enhancedPrompt, ragContext);
  }
} 